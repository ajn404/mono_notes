---
title: 部分八股文记录
author: ajn404
pubDatetime: 2023-10-11 14:05:00
postSlug: 8ass
featured: false
draft: false
tags:
  - 八股
description:
  "八股文"
---

## 目录

## 命令

### 网络

- ping – send ICMP ECHO_REQUEST packets to network hosts
>  The ping utility uses the ICMP protocol's mandatory ECHO_REQUEST datagram to elicit an ICMP ECHO_RESPONSE from a host or gateway.  ECHO_REQUEST datagrams
     (“pings”) have an IP and ICMP header, followed by a “struct timeval” and then an arbitrary number of “pad” bytes used to fill out the packet. 

> ICMP
ICMP（Internet Control Message Protocol）是一种网络协议，用于在IP层发送控制消息。这些消息用于检查网络连接的可靠性、维护网络配置等。ICMP协议的主要用途是检测网络设备的状态和运行情况。

以下是一些常见的ICMP协议消息类型：

PING（回显请求）：用于检查目标主机是否正常运行。
TCP Port Unreachable：表示目标主机上的特定TCP端口无法访问。
TTL Expired：表示数据包在传输过程中超过了指定的生存时间（TTL）。
ICMPv6：用于IPv6网络中的ICMP消息。

## 框架

### vue



### react

#### Refactoring to input with State

- 1.Identify your component’s different visual states

通过props控制虚拟dom

<details>
<summary>from.tsx</summary>
```tsx
export default function Form({
  status = 'empty'
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea disabled={
          status === 'submitting'
        } />
        <br />
        <button disabled={
          status === 'empty' ||
          status === 'submitting'
        }>
          Submit
        </button>
        {status === 'error' &&
          <p className="Error">
            Good guess but a wrong answer. Try again!
          </p>
        }
      </form>
      </>
  );
}
```
</details>

<details>
<summary>App.ts</summary>
```ts
import Form from './Form.js';

let statuses = [
  'empty',
  'typing',
  'submitting',
  'success',
  'error',
];

export default function App() {
  return (
    <>
      {statuses.map(status => (
        <section key={status}>
          <h4>Form ({status}):</h4>
          <Form status={status} />
        </section>
      ))}
    </>
  );
}
```
</details>


- 2.Determine what triggers those state changes
- 3.Represent the state in memory with useState

```js
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
```

- 4.Remove any non-essential state variables 
- 5 .Connect the event handlers to set state

<details>
<summary>App.ts</summary>

```ts
import { useState } from 'react';

export default function Form() {
  const [answer, setAnswer] = useState('');
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('typing');

  if (status === 'success') {
    return <h1>That's right!</h1>
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('submitting');
    try {
      await submitForm(answer);
      setStatus('success');
    } catch (err) {
      setStatus('typing');
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === 'submitting'}
        />
        <br />
        <button disabled={
          answer.length === 0 ||
          status === 'submitting'
        }>
          Submit
        </button>
        {error !== null &&
          <p className="Error">
            {error.message}
          </p>
        }
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== 'lima'
      if (shouldError) {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      } else {
        resolve();
      }
    }, 1500);
  });
}
```
</details>


## canvas

### 绘制三角形或多边形


<details>
<summary>index.js</summary>
```js
   const canvas = document.getElementById('myCanvas');
   const ctx = canvas.getContext('2d');
   // 绘制三角形
   ctx.beginPath();
   ctx.moveTo(10, 10);
   ctx.lineTo(50, 100);
   ctx.lineTo(10, 150);
   ctx.closePath();
   ctx.fillStyle = 'blue';
   ctx.fill();

   // 绘制多边形
   ctx.beginPath();
   ctx.moveTo(150, 10);
   ctx.lineTo(200, 50);
   ctx.lineTo(150, 100);
   ctx.lineTo(100, 50);
   ctx.closePath();
   ctx.fillStyle = 'red';
   ctx.fill();
```

</details>


<canvas id="myCanvas" class="h-[100px] w-[100px] bg-[#000]"/>


## 基础

### 防抖

 n 秒内函数只会执行一次
```js
function debounce(fn, timing) {
  let timer;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn();
    }, timing);
  }
}
```

```
const debounce = (fn, delay) => {
    let timer;
    return ()=>{
        clearTimeout(timer);
        timer = setTimeout(()=>{
            fn();
        }, delay);
    }
}
```

常用于避免事件处理程序或函数被频繁触发，从而提高性能。例如，在搜索输入框中，当用户输入时，可能会触发一个搜索函数，但这个函数可能会被频繁触发，导致性能下降。使用 debounce 函数可以解决这个问题，确保搜索函数只在用户停止输入后的 delay 毫秒后执行。

### 节流

```js
function throttle(fn, timing) {
  let trigger;
  return function() {
    if (trigger) return;
    trigger = true;
    fn();
    setTimeout(() => {
      trigger = false;
    }, timing);
  }
}
```

常用于限制函数的执行频率，从而提高性能。例如，在滚动事件处理程序中，可能会触发一个函数来重新获取页面内容，但这个函数可能会被频繁触发，导致性能下降。使用 throttle 函数可以解决这个问题，确保在滚动事件触发后的 timing 时间间隔内只执行一次函数。


## 实现(5).add(3).minus(2)功能

```js
Number.prototype.add = function(num) {
    return this+num
}

Number.prototype.minus = function(num) {
    return this-num
}

Number.prototype.multiply = function(num) {
    return this*num
}

Number.prototype.divide = function(num) {
    return this/num
}
```

## Async/Await 如何通过同步的方式实现异步

generate 

```js
var fetch = require("node-fetch");

function *gen() { // 这里的 * 可以看成 async
  var url = "https://api.github.com/users/github";
  var result = yield fetch(url); // 这里的 yield 可以看成 await
  console.log(result.bio);
}

var g = gen();
var result = g.next();
result.value.then(data => data.json()).then(data  => g.next(data));
```

## 浏览器渲染原理


浏览器的渲染原理可以简单地描述为以下几个步骤:

### 解析 HTML:

浏览器将 HTML 文档解析成 DOM(文档对象模型)树,以便浏览器可以理解和操作 HTML 元素。

浏览器解析 HTML 时使用的方案主要有两种：SAX 和 DOM。

SAX（Simple API for XML）解析器：SAX 解析器是一种基于事件驱动的解析方式，它会将 HTML 文件分割成一系列的事件，然后逐个处理这些事件。SAX 解析器不会将整个 HTML 文档加载到内存中，因此非常适合处理大型的 HTML 文档。SAX 解析器的主要缺点是，它不支持在解析过程中修改 DOM（Document Object Model，文档对象模型）。
DOM（Document Object Model）解析器：DOM 解析器会将 HTML 文件解析成 DOM 树，然后通过 DOM API 进行操作。DOM 解析器会将整个 HTML 文档加载到内存中，因此适用于需要对 HTML 文件进行复杂操作的场景。DOM 解析器的主要优点是支持在解析过程中修改 DOM，但可能会导致解析速度变慢。
在实际应用中，浏览器通常会根据 HTML 文档的大小和复杂程度选择合适的解析方式。对于较小的 HTML 文档，SAX 解析器更为高效；而对于较大的 HTML 文档，DOM 解析器更为高效。此外，浏览器可能会在解析过程中自动切换解析方式，以提高性能。

需要注意的是，尽管 DOM 解析器支持在解析过程中修改 DOM，但在解析完成后，浏览器可能会对 DOM 进行优化，例如清除不再需要的节点、压缩 DOM 等，以减小内存占用和提高性能。因此，在实际应用中，尽量使用 DOM 解析器，并在解析完成后进行优化。


### 解析 CSS:
浏览器将 CSS 样式表解析成 CSSOM(样式对象模型)树,以便浏览器可以理解和应用 CSS 规则。

### 构建渲染树:

浏览器将 DOM 和 CSSOM 合并成一个渲染树,以便浏览器可以绘制屏幕上的内容。

### 布局:

浏览器使用布局引擎计算渲染树中每个节点的宽度和高度,以便将它们放置在屏幕上的适当位置。
### 绘制:

浏览器使用 GPU(图形处理单元)绘制渲染树中的每个节点,以便将它们显示在屏幕上。

### 重排和重绘:

如果渲染树中的某个节点发生了变化,例如,元素的属性或内容发生了变化,那么浏览器将重新计算渲染树,并重新绘制屏幕上的内容。这个过程被称为重排。如果只是修改了某个节点的属性,例如,修改了它的样式或大小,那么浏览器将只重新计算需要重新绘制的部分,这个过程被称为重绘。
浏览器渲染过程的复杂性在于,它需要同时处理 HTML、CSS 和布局。此外,浏览器需要处理多种设备类型和屏幕尺寸,以确保网页在不同设备和屏幕上都能正常显示。因此,浏览器的渲染原理可以被视为一种复杂的高级算法。




## 链接

- [react docs](https://react.dev/)




