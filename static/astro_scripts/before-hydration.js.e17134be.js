import{j as d,T as f,i as y,t as A,v,a as p,e as P,D as $}from"../directive-helpers.ea3d1013.js";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const g={boundAttributeSuffix:d.O,marker:d.P,markerMatch:d.A,HTML_RESULT:d.C,getTemplateHtml:d.M,overrideDirectiveResolve:(r,a)=>class extends r{_$AS(l,o){return a(this,o)}},setDirectiveClass(r,a){r._$litDirective$=a},getAttributePartCommittedValue:(r,a,l)=>{let o=f;return r.j=e=>o=e,r._$AI(a,r,l),o},connectedDisconnectable:r=>({...r,_$AU:!0}),resolveDirective:d.D,AttributePart:d.V,PropertyPart:d.U,BooleanAttributePart:d.H,EventPart:d.N,ElementPart:d.F,TemplateInstance:d.L,isIterable:d.R,ChildPart:d.I};/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const{TemplateInstance:w,isIterable:E,resolveDirective:m,ChildPart:h,ElementPart:x}=g,_=(r,a,l={})=>{if(a._$litPart$!==void 0)throw Error("container already contains a live render");let o,e,n;const t=[],c=document.createTreeWalker(a,NodeFilter.SHOW_COMMENT,null,!1);let i;for(;(i=c.nextNode())!==null;){const s=i.data;if(s.startsWith("lit-part")){if(t.length===0&&o!==void 0)throw Error(`There must be only one root part per container. Found a part marker (${i}) when we already have a root part marker (${e})`);n=T(r,i,t,l),o!=null||(o=n),e!=null||(e=i)}else if(s.startsWith("lit-node"))R(i,t,l);else if(s.startsWith("/lit-part")){if(t.length===1&&n!==o)throw Error("internal error");n=I(i,n,t)}}if(o===void 0){const s=a instanceof ShadowRoot?"{container.host.localName}'s shadow root":a instanceof DocumentFragment?"DocumentFragment":a.localName;console.error(`There should be exactly one root part in a render container, but we didn't find any in ${s}.`)}a._$litPart$=o},T=(r,a,l,o)=>{let e,n;if(l.length===0)n=new h(a,null,void 0,o),e=r;else{const t=l[l.length-1];if(t.type==="template-instance")n=new h(a,null,t.instance,o),t.instance._$AV.push(n),e=t.result.values[t.instancePartIndex++],t.templatePartIndex++;else if(t.type==="iterable"){n=new h(a,null,t.part,o);const c=t.iterator.next();if(c.done)throw e=void 0,t.done=!0,Error("Unhandled shorter than expected iterable");e=c.value,t.part._$AH.push(n)}else n=new h(a,null,t.part,o)}if(e=m(n,e),e===f)l.push({part:n,type:"leaf"});else if(y(e))l.push({part:n,type:"leaf"}),n._$AH=e;else if(A(e)){if(v(e))throw Error("compiled templates are not supported");const t="lit-part "+C(e);if(a.data!==t)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const c=h.prototype._$AC(e),i=new w(c,n);l.push({type:"template-instance",instance:i,part:n,templatePartIndex:0,instancePartIndex:0,result:e}),n._$AH=i}}else E(e)?(l.push({part:n,type:"iterable",value:e,iterator:e[Symbol.iterator](),done:!1}),n._$AH=[]):(l.push({part:n,type:"leaf"}),n._$AH=e??"");return n},I=(r,a,l)=>{if(a===void 0)throw Error("unbalanced part marker");a._$AB=r;const o=l.pop();if(o.type==="iterable"&&!o.iterator.next().done)throw Error("unexpected longer than expected iterable");if(l.length>0)return l[l.length-1].part},R=(r,a,l)=>{const o=/lit-node (\d+)/.exec(r.data),e=parseInt(o[1]),n=r.nextElementSibling;if(n===null)throw Error("could not find node for attribute parts");n.removeAttribute("defer-hydration");const t=a[a.length-1];if(t.type!=="template-instance")throw Error("internal error");{const c=t.instance;for(;;){const i=c._$AD.parts[t.templatePartIndex];if(i===void 0||i.type!==p.ATTRIBUTE&&i.type!==p.ELEMENT||i.index!==e)break;if(i.type===p.ATTRIBUTE){const s=new i.ctor(n,i.name,i.strings,t.instance,l),u=P(s)?t.result.values[t.instancePartIndex]:t.result.values,b=!(s.type===p.EVENT||s.type===p.PROPERTY);s._$AI(u,s,t.instancePartIndex,b),t.instancePartIndex+=i.strings.length-1,c._$AV.push(s)}else{const s=new x(n,t.instance,l);m(s,t.result.values[t.instancePartIndex++]),c._$AV.push(s)}t.templatePartIndex++}}},C=r=>{const a=new Uint32Array(2).fill(5381);for(const o of r.strings)for(let e=0;e<o.length;e++)a[e%2]=33*a[e%2]^o.charCodeAt(e);const l=String.fromCharCode(...new Uint8Array(a.buffer));return btoa(l)};globalThis.litElementHydrateSupport=({LitElement:r})=>{const a=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(r),"observedAttributes").get;Object.defineProperty(r,"observedAttributes",{get(){return[...a.call(this),"defer-hydration"]}});const l=r.prototype.attributeChangedCallback;r.prototype.attributeChangedCallback=function(t,c,i){t==="defer-hydration"&&i===null&&o.call(this),l.call(this,t,c,i)};const o=r.prototype.connectedCallback;r.prototype.connectedCallback=function(){this.hasAttribute("defer-hydration")||o.call(this)};const e=r.prototype.createRenderRoot;r.prototype.createRenderRoot=function(){return this.shadowRoot?(this._$AG=!0,this.shadowRoot):e.call(this)};const n=Object.getPrototypeOf(r.prototype).update;r.prototype.update=function(t){const c=this.render();if(n.call(this,t),this._$AG){this._$AG=!1;for(let i=0;i<this.attributes.length;i++){const s=this.attributes[i];if(s.name.startsWith("hydrate-internals-")){const u=s.name.slice(18);this.removeAttribute(u),this.removeAttribute(s.name)}}_(c,this.renderRoot,this.renderOptions)}else $(c,this.renderRoot,this.renderOptions)}};
